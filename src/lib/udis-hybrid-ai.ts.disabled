/**
 * UDIS Hybrid AI System
 * 
 * Combines Claude Code (Claude Sonnet 4) for deep analysis with GPT-4o-mini for monitoring
 * - Claude Code: Complex problem analysis, architectural insights, comprehensive solutions
 * - GPT-4o-mini: Real-time monitoring, quick pattern detection, cost-effective alerts
 */

import { DetectedIssue, ProblemDomain, IssueSeverity, UDISConfig } from './udis-core'
import { aiService } from './ai-service'

// AI Model Selection Strategy
export enum AIModelTier {
  LIGHTWEIGHT = 'lightweight',    // GPT-4o-mini for quick analysis
  COMPREHENSIVE = 'comprehensive', // Claude Sonnet 4 for deep analysis
  HYBRID = 'hybrid'               // Intelligent routing between both
}

// Analysis complexity levels
export enum AnalysisComplexity {
  SIMPLE = 'simple',           // Pattern matching, known issues
  MODERATE = 'moderate',       // Multi-step analysis needed
  COMPLEX = 'complex',         // Architecture-level insights required
  CRITICAL = 'critical'        // Emergency situations requiring best AI
}

// Claude Code Integration Interface
interface ClaudeCodeAnalysis {
  analysis: string
  confidence: number
  architecturalInsights: string[]
  codeRecommendations: string[]
  preventionStrategy: string
  estimatedImpact: string
  followUpActions: string[]
}

// Hybrid AI Configuration
export interface HybridAIConfig {
  enableClaudeCode: boolean
  claudeCodePort: number          // Port 3001 for test deployment
  claudeCodeEndpoint: string      // Local Claude Code API endpoint
  fallbackToGPT4oMini: boolean   // Fallback if Claude Code unavailable
  intelligentRouting: boolean     // Auto-select best model for each issue
  costOptimization: boolean       // Prefer cheaper model when possible
  emergencyEscalation: boolean    // Use Claude Code for critical issues
}

/**
 * Hybrid AI Analysis Engine
 * Routes issues to appropriate AI model based on complexity and availability
 */
export class HybridAIEngine {
  private config: HybridAIConfig
  private claudeCodeAvailable = false
  private costTracker = {
    claudeCodeCalls: 0,
    gpt4oMiniCalls: 0,
    totalCost: 0
  }

  constructor(config: Partial<HybridAIConfig> = {}) {
    this.config = {
      enableClaudeCode: true,
      claudeCodePort: 3001,
      claudeCodeEndpoint: 'http://localhost:3001',
      fallbackToGPT4oMini: true,
      intelligentRouting: true,
      costOptimization: true,
      emergencyEscalation: true,
      ...config
    }

    this.initializeClaudeCodeConnection()
  }

  /**
   * Initialize connection to Claude Code running on port 3001
   */
  private async initializeClaudeCodeConnection(): Promise<void> {
    if (!this.config.enableClaudeCode) return

    try {
      // Test Claude Code availability
      const response = await fetch(`${this.config.claudeCodeEndpoint}/health`, {
        method: 'GET',
        timeout: 5000
      })

      this.claudeCodeAvailable = response.ok
      console.log(`[UDIS:HybridAI] Claude Code ${this.claudeCodeAvailable ? 'available' : 'unavailable'} on port ${this.config.claudeCodePort}`)

    } catch (error) {
      this.claudeCodeAvailable = false
      console.log('[UDIS:HybridAI] Claude Code not available, will use GPT-4o-mini only')
    }
  }

  /**
   * Analyze issue using intelligent AI model selection
   */
  public async analyzeIssue(issue: DetectedIssue): Promise<{
    analysis: string,
    modelUsed: string,
    confidence: number,
    recommendations: string[],
    architecturalInsights?: string[],
    cost: number
  }> {
    // Determine analysis complexity
    const complexity = this.determineComplexity(issue)
    
    // Select appropriate AI model
    const modelTier = this.selectAIModel(complexity, issue.severity)
    
    console.log(`[UDIS:HybridAI] Analyzing "${issue.title}" with ${modelTier} model (complexity: ${complexity})`)

    try {
      if (modelTier === AIModelTier.COMPREHENSIVE && this.claudeCodeAvailable) {
        return await this.analyzeWithClaudeCode(issue, complexity)
      } else {
        return await this.analyzeWithGPT4oMini(issue, complexity)
      }
    } catch (error) {
      console.error('[UDIS:HybridAI] Analysis failed:', error)
      
      // Fallback strategy
      if (modelTier === AIModelTier.COMPREHENSIVE && this.config.fallbackToGPT4oMini) {
        console.log('[UDIS:HybridAI] Falling back to GPT-4o-mini')
        return await this.analyzeWithGPT4oMini(issue, complexity)
      }
      
      throw error
    }
  }

  /**
   * Determine analysis complexity based on issue characteristics
   */
  private determineComplexity(issue: DetectedIssue): AnalysisComplexity {
    // Critical severity always gets complex analysis
    if (issue.severity === IssueSeverity.CRITICAL) {
      return AnalysisComplexity.CRITICAL
    }

    // Architecture and security issues need comprehensive analysis
    if (issue.domain === ProblemDomain.SECURITY || 
        issue.title.toLowerCase().includes('architecture') ||
        issue.title.toLowerCase().includes('design pattern')) {
      return AnalysisComplexity.COMPLEX
    }

    // Performance and build issues often need moderate analysis
    if (issue.domain === ProblemDomain.PERFORMANCE || 
        issue.domain === ProblemDomain.BUILD) {
      return AnalysisComplexity.MODERATE
    }

    // Simple issues for basic monitoring
    return AnalysisComplexity.SIMPLE
  }

  /**
   * Select AI model based on complexity and configuration
   */
  private selectAIModel(complexity: AnalysisComplexity, severity: IssueSeverity): AIModelTier {
    // Emergency situations always use best available AI
    if (complexity === AnalysisComplexity.CRITICAL || severity === IssueSeverity.CRITICAL) {
      return this.claudeCodeAvailable ? AIModelTier.COMPREHENSIVE : AIModelTier.LIGHTWEIGHT
    }

    // Cost optimization: use cheaper model when possible
    if (this.config.costOptimization && complexity === AnalysisComplexity.SIMPLE) {
      return AIModelTier.LIGHTWEIGHT
    }

    // Intelligent routing based on complexity
    if (this.config.intelligentRouting) {
      if (complexity === AnalysisComplexity.COMPLEX && this.claudeCodeAvailable) {
        return AIModelTier.COMPREHENSIVE
      }
      if (complexity === AnalysisComplexity.MODERATE && this.claudeCodeAvailable && Math.random() > 0.5) {
        return AIModelTier.COMPREHENSIVE // 50% chance for moderate complexity
      }
    }

    return AIModelTier.LIGHTWEIGHT
  }

  /**
   * Analyze using Claude Code (Claude Sonnet 4) via local port 3001
   */
  private async analyzeWithClaudeCode(issue: DetectedIssue, complexity: AnalysisComplexity): Promise<any> {
    const prompt = this.buildClaudeCodePrompt(issue, complexity)
    
    try {
      const response = await fetch(`${this.config.claudeCodeEndpoint}/api/analyze`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          prompt,
          model: 'claude-sonnet-4',
          maxTokens: 2000,
          temperature: 0.1
        })
      })

      if (!response.ok) {
        throw new Error(`Claude Code API error: ${response.status}`)
      }

      const data = await response.json()
      
      // Track usage
      this.costTracker.claudeCodeCalls++
      this.costTracker.totalCost += 0.15 // Estimated cost per Claude Code call

      return {
        analysis: data.analysis || data.content,
        modelUsed: 'Claude Sonnet 4 (via Claude Code)',
        confidence: 0.9, // Claude Sonnet 4 has high confidence
        recommendations: data.recommendations || [],
        architecturalInsights: data.architecturalInsights || [],
        cost: 0.15
      }

    } catch (error) {
      console.error('[UDIS:HybridAI] Claude Code analysis failed:', error)
      throw error
    }
  }

  /**
   * Build comprehensive prompt for Claude Code analysis
   */
  private buildClaudeCodePrompt(issue: DetectedIssue, complexity: AnalysisComplexity): string {
    return `You are a senior software architect and development intelligence expert analyzing a ${complexity} issue in a Next.js/TypeScript application.

ISSUE ANALYSIS REQUEST:
- Title: ${issue.title}
- Domain: ${issue.domain}
- Severity: ${issue.severity}
- Description: ${issue.description}
- Context: ${JSON.stringify(issue.context, null, 2)}

APPLICATION CONTEXT:
- Framework: Next.js 14 with TypeScript
- Database: PostgreSQL with Prisma ORM
- AI Integration: OpenRouter with GPT-4o-mini
- Deployment: Vercel
- Purpose: AI-powered character creation system (Lightwalker)

COMPREHENSIVE ANALYSIS REQUIRED:
1. **Root Cause Analysis**: Deep dive into what caused this issue
2. **Architectural Assessment**: How does this relate to overall system architecture?
3. **Code Quality Impact**: What does this reveal about code patterns and practices?
4. **Performance Implications**: How does this affect system performance?
5. **Security Considerations**: Any security implications?
6. **Scalability Impact**: How will this affect scaling to 100+ users?
7. **Prevention Strategy**: Comprehensive approach to prevent similar issues
8. **Implementation Recommendations**: Specific, actionable solutions
9. **Monitoring Improvements**: How to detect similar issues earlier
10. **Technical Debt Assessment**: What technical debt does this expose?

RESPOND WITH STRUCTURED JSON:
{
  "analysis": "comprehensive analysis of the issue",
  "rootCause": "detailed root cause explanation",
  "architecturalInsights": ["insight 1", "insight 2", "insight 3"],
  "codeRecommendations": ["recommendation 1", "recommendation 2"],
  "performanceImpact": "assessment of performance implications",
  "securityImplications": "security considerations",
  "scalabilityGuidance": "scaling recommendations",
  "preventionStrategy": "comprehensive prevention approach",
  "implementationSteps": ["step 1", "step 2", "step 3"],
  "monitoringImprovements": ["monitoring enhancement 1", "enhancement 2"],
  "technicalDebtAssessment": "technical debt implications",
  "confidence": 0.95,
  "estimatedImpact": "high|medium|low",
  "priority": "critical|high|medium|low"
}

Focus on providing actionable, implementable recommendations that improve both the immediate issue and the overall system quality.`
  }

  /**
   * Analyze using GPT-4o-mini (existing AI service)
   */
  private async analyzeWithGPT4oMini(issue: DetectedIssue, complexity: AnalysisComplexity): Promise<any> {
    const prompt = this.buildGPT4oMiniPrompt(issue, complexity)
    
    try {
      // Use existing AI service infrastructure
      const response = await this.callOpenRouterAPI(prompt)
      
      // Track usage
      this.costTracker.gpt4oMiniCalls++
      this.costTracker.totalCost += 0.02 // Estimated cost per GPT-4o-mini call

      const parsed = this.parseAIResponse(response)

      return {
        analysis: parsed.analysis,
        modelUsed: 'GPT-4o-mini (via OpenRouter)',
        confidence: parsed.confidence || 0.7,
        recommendations: parsed.recommendations || [],
        cost: 0.02
      }

    } catch (error) {
      console.error('[UDIS:HybridAI] GPT-4o-mini analysis failed:', error)
      throw error
    }
  }

  /**
   * Build focused prompt for GPT-4o-mini
   */
  private buildGPT4oMiniPrompt(issue: DetectedIssue, complexity: AnalysisComplexity): string {
    return `Analyze this ${complexity} development issue quickly and provide practical solutions:

ISSUE: ${issue.title}
DOMAIN: ${issue.domain}
SEVERITY: ${issue.severity}
DESCRIPTION: ${issue.description}
CONTEXT: ${JSON.stringify(issue.context)}

QUICK ANALYSIS NEEDED:
1. Root cause (concise)
2. Practical solution
3. Is this auto-fixable?
4. Prevention tip

RESPOND IN JSON:
{
  "analysis": "concise root cause analysis",
  "solution": "practical fix recommendation", 
  "autoFixable": true/false,
  "preventionTip": "brief prevention strategy",
  "confidence": 0.8,
  "recommendations": ["fix 1", "fix 2"]
}

Keep response focused and actionable for Next.js/TypeScript development.`
  }

  /**
   * Call OpenRouter API (reusing existing infrastructure)
   */
  private async callOpenRouterAPI(prompt: string): Promise<string> {
    const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${process.env.OPENROUTER_API_KEY}`,
        'Content-Type': 'application/json',
        'HTTP-Referer': 'https://lightwalker-mvp.vercel.app',
        'X-Title': 'UDIS Hybrid AI Analysis'
      },
      body: JSON.stringify({
        model: 'openai/gpt-4o-mini',
        messages: [{
          role: 'system',
          content: 'You are an expert development intelligence analyst. Provide structured JSON responses.'
        }, {
          role: 'user',
          content: prompt
        }],
        max_tokens: 1000,
        temperature: 0.1
      })
    })

    if (!response.ok) {
      throw new Error(`OpenRouter API error: ${response.status}`)
    }

    const data = await response.json()
    return data.choices[0]?.message?.content || ''
  }

  /**
   * Parse AI response (reusing existing logic)
   */
  private parseAIResponse(response: string): any {
    try {
      let cleanContent = response.trim()
      
      if (cleanContent.startsWith('```json')) {
        cleanContent = cleanContent.slice(7)
      }
      if (cleanContent.endsWith('```')) {
        cleanContent = cleanContent.slice(0, -3)
      }
      
      return JSON.parse(cleanContent.trim())
      
    } catch (error) {
      console.error('[UDIS:HybridAI] Failed to parse AI response:', error)
      return {
        analysis: 'AI response parsing failed',
        confidence: 0.1,
        recommendations: ['Manual investigation required']
      }
    }
  }

  /**
   * Get cost and usage statistics
   */
  public getUsageStats(): {
    claudeCodeCalls: number,
    gpt4oMiniCalls: number,
    totalCost: number,
    averageCostPerCall: number,
    recommendedModel: string
  } {
    const totalCalls = this.costTracker.claudeCodeCalls + this.costTracker.gpt4oMiniCalls
    const averageCost = totalCalls > 0 ? this.costTracker.totalCost / totalCalls : 0

    return {
      ...this.costTracker,
      averageCostPerCall: averageCost,
      recommendedModel: this.claudeCodeAvailable ? 
        'Hybrid (Claude Code + GPT-4o-mini)' : 'GPT-4o-mini only'
    }
  }

  /**
   * Force analysis with Claude Code (for testing)
   */
  public async analyzeWithClaudeCodeForced(issue: DetectedIssue): Promise<any> {
    if (!this.claudeCodeAvailable) {
      throw new Error('Claude Code not available')
    }
    
    return await this.analyzeWithClaudeCode(issue, AnalysisComplexity.COMPLEX)
  }

  /**
   * Test Claude Code connection
   */
  public async testClaudeCodeConnection(): Promise<boolean> {
    await this.initializeClaudeCodeConnection()
    return this.claudeCodeAvailable
  }
}

/**
 * Example usage with your DeepSeek R1 scenario
 */
export class DeepSeekR1Detector extends HybridAIEngine {
  /**
   * This would have automatically detected and resolved your DeepSeek R1 issues
   */
  public async analyzeAIServiceIssue(
    model: string, 
    responseTime: number, 
    error?: Error
  ): Promise<void> {
    // Create issue from AI service problem
    const issue: DetectedIssue = {
      id: `ai-service-${model}-${Date.now()}`,
      timestamp: new Date(),
      domain: ProblemDomain.INFRASTRUCTURE,
      severity: responseTime > 30000 ? IssueSeverity.CRITICAL : IssueSeverity.HIGH,
      title: `AI Service Issue: ${model}`,
      description: error ? 
        `${model} failed: ${error.message}` : 
        `${model} response time: ${Math.round(responseTime/1000)}s`,
      context: {
        metadata: { 
          model, 
          responseTime, 
          error: error?.message,
          durationSeconds: responseTime / 1000
        }
      },
      autoFixable: true,
      similarIssues: []
    }

    // Analyze with hybrid AI
    const analysis = await this.analyzeIssue(issue)
    
    console.log(`[UDIS:DeepSeekDetector] Analysis complete:`)
    console.log(`Model Used: ${analysis.modelUsed}`)
    console.log(`Analysis: ${analysis.analysis}`)
    console.log(`Recommendations:`, analysis.recommendations)
    
    if (analysis.architecturalInsights) {
      console.log(`Architectural Insights:`, analysis.architecturalInsights)
    }

    // The system would automatically suggest switching from DeepSeek R1 to GPT-4o-mini
    return analysis
  }
}

export default {
  HybridAIEngine,
  DeepSeekR1Detector,
  AIModelTier,
  AnalysisComplexity
}